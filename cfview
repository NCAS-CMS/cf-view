#!/usr/bin/env python2.7

import pygtk
import gtk
import cf
import guiWidgets as gw
import plotConfigWidgets as pcw
import sys
import cfplot as cfp
import numpy as np
import matplotlib.pyplot as plt

__version__='0.3.1'

cfgPadding=5

#Define a persistent pvars instance to store data across plotting
class pvars(object):
   def __init__(self, **kwargs):
      '''Initialize a new Pvars instance'''
      for attr, value in kwargs.iteritems():
         setattr(self, attr, value)

   def __str__(self):
      '''x.__str__() <==> str(x)'''
      out = ['%s = %s' % (a, repr(v))]
      for a, v in self.__dict__.iteritems():
         return '\n'.join(out)


plotvars=pvars(pos=0, nplots=1, code='', vect_ufield=None,vect_key_length=5, vect_pts=None, \
               vect_scale=5, vect_title=None, plot_counter=0, title='', field_selected='',\
               file_selected=''\
               )
''' 
   plotvars is a set of persistent variables to store various parameters
   across plotting actions such as multiple plots.

   pos=None - current plot position in multiple plot mode 
   nplots=1 - number of plots in multiple plot mode
   code='' - Python and cfplot commands used to make the present plot
   vect_ufield=None - u field for vector plot
   vect_key_length=5 - length of reference vector
   vect_pts=None - number of point to impterpolate to for vectors
   vect_scale=5 - data units per arrow unit length
   vect_title='' - vector title 
   plot_finish=0 - number of plots to make for this type of plot.  
                   For graph and contour this is set to 1, vector to 2 and contour and vector to 3.
   plot_counter=0 - present plot number
   title='' - title for plot
   field_selected='' - field selected from currently loaded data
   file_selected='' - file currently selected
'''


class cfview:
    ''' Provides the main frame for cfview '''
    def __init__(self, filename):
        ''' Create main window as a notebook with three panes:
                Discover
                Inspect
                Plot
            Provide a status window underneath and a toolbar above.
        '''
        
        window=gtk.Window(gtk.WINDOW_TOPLEVEL)
        window.connect('delete_event',self.delete)
        window.set_border_width(cfgPadding)
        
        # box for all main window elements
        vbox=gtk.VBox()
        window.add(vbox)
        
        # get menubar
        menubar=self.get_mainMenu(window)
        vbox.pack_start(menubar,expand=False)
        
        # script record of what is going on 
        #self.script=script(debug=True)
        self.script=script()
        
        # notebook
        nb=gtk.Notebook()
        nb.show_tabs=True
        vbox.pack_start(nb,padding=cfgPadding)
        self.nb=nb
        for a,p,m in [ ('Select',xconvLike,self.script),
                    ('Inspect',gw.guiInspect,self.selector),
                    ('Gallery',gw.guiGallery,self.selector),
                   ]:
            label=gtk.Label(a)
            w=p(m)
            self.nb.append_page(w,label)
            setattr(self,a,w)
            w.show_all()
        
        # status window
        statusbar=gtk.Statusbar()
        statusbar.set_has_resize_grip(False)
        vbox.pack_start(statusbar,padding=cfgPadding,expand=False)
        
        self.w=window
        
        self.default_title=' cfview %s'%__version__
        self.set_title(self.default_title)
        
        window.show_all()
        
        if filename is not None:
            self.reset_with(filename)
        
    def selector(self):
        ''' Callback to mediate the various panes. May need to be
        a class with methods ... '''
        #FIXME
        pass
        
    def get_mainMenu(self,w):
        
        ''' Build a menuBar toolbar using the gtk uimanager '''
        
        ui = '''<ui>
            <menubar name="MenuBar">
                <menu action="File">
                    <menuitem action="Load"/>
                    <separator/>
                    <menuitem action="Save"/>
                    <separator/>
                    <menuitem action="Quit"/>
                </menu>
                <menu action="View">
                    <menuitem action="Code"/>
                </menu>
                <menu action="Help">
                    <menuitem action="About"/>
                </menu>
            </menubar>
            </ui>
            '''
        uimanager = gtk.UIManager()
        
        accelgroup = uimanager.get_accel_group()
        w.add_accel_group(accelgroup)
        
        actiongroup=gtk.ActionGroup('cfview')
        
        actiongroup.add_actions ([
                ('File',None,'_File'),
                ('Load',gtk.STOCK_OPEN,'Load File',None,
                 'Load File',self.file_load),
                ('Save',gtk.STOCK_OPEN,'Save code',None,
                 'Save code',self.code_save),
                 ('Quit',gtk.STOCK_QUIT,'Quit',None,
                 'Quit',self.delete),
                ('View',None,'_View'),
                ('Code',gtk.STOCK_OPEN,'Code', None,
                'View plot code',code_show),
                ('Help',None,'_Help'),
                ('About',gtk.STOCK_HELP,'About', None,
                'About cfview',self.help_about),
                ])


        
        uimanager.insert_action_group(actiongroup, 0)
        uimanager.add_ui_from_string(ui)
        
        widget=uimanager.get_widget('/MenuBar')
        
        # make sure the help menu is on the right
        helpmenu = uimanager.get_widget('/MenuBar/Help')
        helpmenu.set_right_justified(True)         
        
        return widget
        
    def file_load(self,b):
        ''' Open a file for cfview. '''
        chooser=gtk.FileChooserDialog(title='Open data file',
                    action=gtk.FILE_CHOOSER_ACTION_OPEN,
                    buttons=(   gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,
                                gtk.STOCK_OPEN,gtk.RESPONSE_OK),
                    )
        response=chooser.run()
        if response==gtk.RESPONSE_OK:
            newfile=chooser.get_filename()
            self.reset_with(newfile)
        chooser.destroy()

    def code_save(self,b):
        ''' Save code to make current plot'''
        chooser=gtk.FileChooserDialog(title='Save code to make current plot',
                    action=gtk.FILE_CHOOSER_ACTION_SAVE,
                    buttons=(   gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,
                                gtk.STOCK_SAVE,gtk.RESPONSE_OK),
                    )
        chooser.set_current_name('code.py')
        response=chooser.run()
        if response==gtk.RESPONSE_OK:
            savefile=chooser.get_filename()
            f=open(savefile, 'w')
            f.write(plotvars.code)
            f.close()
        chooser.destroy()
        
    def reset_with(self,filename):
        ''' Open dataset filename '''
        data=cf.read(filename)
        self.Select.set_data(data)
        self.Inspect.reset()
        self.Gallery.reset()
        #self.script.open(filename)
        #self.script.start()
        plotvars.plot_code=''
        
    def help_about(self,b):
        ''' Provide an about dialog '''
        m=gtk.AboutDialog()
        m.set_program_name('cfview')
        m.set_copyright ( '(c) National Centre for Atmospheric Science')
        m.set_version(__version__)
        m.set_comments('''
This is a pre-release version of NCAS cfview

Credits to:
    David Hassell - for cf-python
    Andy Heaps - for cfplot
    Mudit Gupta - for the prototype pygtk interface to cfplot
    Bryan Lawrence - for the initial version of cfview
            
            ''')
        m.run()
        m.destroy()



        
    def delete(self,w=None,b=None):
        ''' Delete menu '''
        gtk.main_quit()
        return False
        
    def set_title(self,title):
        ''' Set window title '''
        self.w.set_title(title)

class xconvLike(gw.QuarterFrame):
    ''' Set up an xconv like set of panels with 
            field selection on the top left
            field metadata on the bottom left
            grid metadata on the bottom right
            and a combination of grid selection and actions on the top right
        which of course isn't like xconv, but is more cf-like ...
        
        '''
    def __init__(self,script):
        ''' Initialise with the script recorder '''
        super(xconvLike,self).__init__()
        self.script=script
        self.fieldSelector=gw.fieldSelector(self.selection)
        self.fieldMetadata=gw.fieldMetadata()
        self.gridMetadata=gw.gridMetadata()
        self.gridSelector=gw.gridSelector(ysize=200)
        self.topLeft.add(self.fieldSelector)
        self.bottomLeft.add(self.fieldMetadata)
        self.bottomRight.add(self.gridMetadata)
        self._topRight()
        
    def _topRight(self):
        ''' Combination frame for the top right '''
        topRv=gtk.VBox()
        topRv.pack_start(self._actionBox(),padding=2)
        topRv.pack_start(self.gridSelector,expand=True,fill=True)
        self.topRight.add(topRv)
        
    def _actionBox(self):
        ''' Provides the buttons and callbacks to the actual actions which 
        the routine supports. '''
        actionBox=pcw.plotChoices(callback=self._plot,ysize=90)
        actionBox.show()
        return actionBox
        
    def _plot(self,w,plotOptions):
        ''' Executes a plot given the information returned from the various
        selectors and configuration widgets. In practice we have
            - the grid selector telling us about the data slicing,
            - the field selector telling us about what data to plot, and
            - the plot choices widget giving us the cf plot arguments.
        All we have to do here is configure the plot (possibly including
        dealing with multiple plots on one page). 
        '''

        #Define the start of the plotting script 
        script_start="#\n# script generated by cfview version "+__version__+"\n#\
                      \nimport cf, cfplot as cfp\n\n"
        

        #Extract data
        code='sfield=self.fields[0]'
        exec(code)






        #Single plot
        if plotOptions['nup'] == '1': 
           plotvars.nplots=1
           if plotvars.plot_counter == 0: plotvars.code=script_start


        #Multiple plots
        if plotOptions['nup'] != '1' and plotvars.pos == 0:
           #Set number of plots in gplot from interface nup parameter
           if plotOptions['nup'] == '2x1': 
              code="cfp.gopen(columns=2, rows=1)"
              plotvars.nplots=2
           if plotOptions['nup'] == '1x2': 
              code="cfp.gopen(columns=1, rows=2, orientation='portrait')"
              plotvars.nplots=2
           if plotOptions['nup'] == '2x2': 
              code="cfp.gopen(columns=2, rows=2)"
              plotvars.nplots=4
           if plotOptions['nup'] == '3x2':
              code="cfp.gopen(columns=3, rows=2)"
              plotvars.nplots=6
           if plotOptions['nup'] == '2x3':
              code="cfp.gopen(columns=2, rows=3, orientation='portrait')"
              plotvars.nplots=6
           if plotOptions['nup'] == '3x3':
              code="cfp.gopen(columns=3, rows=3)"
              plotvars.nplots=9
           exec("\n"+code)
           plotvars.code=script_start
           plotvars.code=plotvars.code+code+'\n'

           #Position at first plot
           plotvars.pos=1
           code="cfp.gpos(pos=1)"
           exec(code)
           plotvars.code=plotvars.code+code+'\n\n'
           plotvars.title=''


        

        grid=self.gridSelector.get_selected()
        # check we have some data
        if grid is None:
            dialog=gtk.MessageDialog(None,gtk.DIALOG_DESTROY_WITH_PARENT,
                    gtk.MESSAGE_ERROR,gtk.BUTTONS_CLOSE,
                    'Please select some data before trying to plot!')
            dialog.run()
            dialog.destroy()
            return
       
        # Operate on the first field
        plotvars.code=plotvars.code+'#Read data\n'
        plotvars.code=plotvars.code+"sfield=cf.read('"+sfield.file+"')"+\
                      plotvars.field_selected+'\n\n'




        #Bryan's original code
        # first let's do the subspace selection (if any):
        #kwargs={}
        #self.script.add('kwargs={}',hash=True)
        #for d in grid:
        #    kwargs[d]=cf.wi(grid[d][0],grid[d][1])
        #    self.script.add("kwargs['%s']=cf.wi(%s,%s)"%(d,grid[d][0],grid[d][1]))
        #sfield=sfield.subspace(**kwargs)
        #self.script.add('sfield=sfield.subspace(**kwargs)')


        #New code
        subset_counter=0
        subset_string=''
        for d in grid:
            #Check if field is subsetted by the user
            dmin=np.min(sfield.item(d).array)
            dmax=np.max(sfield.item(d).array)
            tol=abs((dmin-int(dmin))/1e3)
            axis_name=getattr(sfield.item(d), 'standard_name', d)
            if len(sfield.item(d).array) == 1: subset_string=subset_string+\
               ' '+axis_name+':'+str(grid[d][0])+' '

            if (abs(dmin-grid[d][0]) > tol) or (abs(dmax-grid[d][1]) > tol):
               subset_counter=subset_counter+1
               if (abs(grid[d][1]-grid[d][0]) <= tol):
                  #Single value
                  code="sfield=sfield.subspace(%s=%s)"%(axis_name,grid[d][0])
                  subset_string=subset_string+' '+axis_name+':'+str(grid[d][0])+' '
               else:
                  #Range of values
                  code="sfield=sfield.subspace(%s=cf.wi(%s,%s))"%(axis_name,grid[d][0],grid[d][1])

               exec(code)
               if subset_counter == 1: plotvars.code=plotvars.code+'#Subspace the data\n'
               plotvars.code=plotvars.code+code+'\n'

            

        if subset_counter > 0: plotvars.code=plotvars.code+'\n'


        # now, do we have to apply any operators?
        opstring=' '
        op_counter=0
        for d in grid:
            if grid[d][2]<>None:
                op_counter=op_counter+1
                axis_name=getattr(sfield.item(d), 'standard_name', d)
                code="sfield=sfield.collapse('%s',axes='%s')"%(grid[d][2],axis_name)
                exec(code)
                if op_counter == 1: plotvars.code=plotvars.code+'#Apply operators\n'
                plotvars.code=plotvars.code+code+'\n'
                opstring+='%s:%s '%(grid[d][2],sfield.domain.axis_name(d))

        
        if op_counter > 0: plotvars.code=plotvars.code+'\n'




        #Error message if data not of right dimensionality
        ndim=len(sfield.axes(size=cf.gt(1)))
        plot_type=plotOptions['con']['ptype']
        if ndim == 1: plot_type=0
        if ndim < 1 or ndim >2:
           dialog=gtk.MessageDialog(None,gtk.DIALOG_DESTROY_WITH_PARENT,
                  gtk.MESSAGE_ERROR,gtk.BUTTONS_CLOSE,
                  'Please select  1 or 2 dimensional data to plot')
           dialog.run()
           dialog.destroy()
           return

        #Work out the type of plot requested
        if plot_type == 0 or plot_type == 1:  plotvars.plot_finish=1
        if plot_type == 2:  plotvars.plot_finish=2
        if plot_type == 3:  plotvars.plot_finish=3


        # now we know the shape we can check that the plotting options
        # and data shape are consistent.
        message=pcw.checkConsistency(sfield,plotOptions)
        if message <>'':
            # We currently don't know how to plot it
            dialog=gtk.MessageDialog(None,gtk.DIALOG_DESTROY_WITH_PARENT,
                    gtk.MESSAGE_ERROR,gtk.BUTTONS_CLOSE,message)
            dialog.run()
            dialog.destroy()
            return
        
        # ok we really can plot this thing!
        
        # get more titles, and slicing information for multiple plots
        tsList=pcw.getSlicesAndTitles(sfield,plotOptions)

        #reset cfplot before any plot to clear previous settings
        if plotvars.pos == 0: cfp.reset()


         







        #Set title
        #plotvars.title=opstring+subset_string
 
        if plot_type == 0:
           #Plot a graph if 1D            
           plotvars.code=plotvars.code+'#Select data for plot\n'
           code='import numpy as np'
           exec(code)
           plotvars.code=plotvars.code+code+'\n'
           xtitle=''                 
           yunits='Value'
           code="xvals=np.squeeze(sfield.array)"
           exec(code)
           plotvars.code=plotvars.code+code+'\n'
           plotvars.title=sfield.file+opstring+subset_string
           for mydim in sfield.items():
              vals=np.squeeze(sfield.item(mydim).array)                 
              if np.size(vals) > 1: 
                 xpts=vals
                 #code="xpts=np.squeeze(sfield.item('%s').array)"%mydim
                 axis_name=getattr(sfield.item(mydim), 'standard_name', mydim)
                 code="xpts=np.squeeze(sfield.item('%s').array)"%axis_name
                 plotvars.code=plotvars.code+code+'\n'
                 units='Value'
                 #xtitle
                 xtitle=getattr(sfield.item(mydim), 'standard_name', 'NoName')
                 if xtitle == 'NoName': xtitle=getattr(sfield.item(mydim), 'long_name', 'NoName')
                 if xtitle == 'NoName': xtitle=getattr(sfield.item(mydim), 'short_name', 'NoName')
                 if xtitle == 'NoName': xtitle=getattr(sfield.item(mydim), 'ncvar', 'NoName')
                 xunits=getattr(sfield.item(mydim), 'units', 'No units')
                 #ytitle
                 if hasattr(sfield, 'ncvar'): ytitle=sfield.ncvar
                 if hasattr(sfield, 'short_name'): ytitle=sfield.short_name 
                 if hasattr(sfield, 'long_name'): ytitle=sfield.long_name 
                 if hasattr(sfield, 'standard_name'): ytitle=sfield.standard_name
                 if hasattr(sfield, 'Units'): yunits=sfield.Units
             

           plotvars.code=plotvars.code+'\n#Make a graph plot\n'

           #Open the plot if a single plot
           if plotvars.nplots == 1:
              code="cfp.gopen()"
              exec("\n"+code)
              plotvars.code=plotvars.code+code+'\n'

           #Plot the graph
           code="cfp.plotvars.plot.tick_params(direction='out', which='both')"
           exec(code)
           plotvars.code=plotvars.code+code+'\n'
           code="cfp.plotvars.plot.set_xlabel('%s(%s)')"%(xtitle,xunits)
           exec(code)
           plotvars.code=plotvars.code+code+'\n'
           code="cfp.plotvars.plot.set_ylabel('%s(%s)')"%(ytitle,yunits)
           exec(code)
           plotvars.code=plotvars.code+code+'\n'
           code="cfp.plotvars.plot.plot(xpts, xvals)"
           exec(code)
           plotvars.code=plotvars.code+code+'\n'
           code="cfp.plotvars.plot.set_title('%s')"%plotvars.title
           exec(code)
           plotvars.code=plotvars.code+code+'\n'
           #Close the plot if a single plot
           if plotvars.nplots == 1:
              code="cfp.gclose()"
              exec(code)
              plotvars.code=plotvars.code+code+'\n'
           else:
              #Move onto next plot
              plotvars.pos=plotvars.pos+1
              if plotvars.pos <= plotvars.nplots: 
                 code="cfp.gpos(pos=%s)"%plotvars.pos
                 exec(code)
                 plotvars.code=plotvars.code+'\n#Move to next plot position\n'
                 plotvars.code=plotvars.code+code+'\n\n'



        #vector plot
        if ndim == 2 and (plot_type == 2 or plot_type == 3):
           fname=''
           units=''
           if hasattr(sfield, 'ncvar'): fname=sfield.ncvar
           if hasattr(sfield, 'short_name'): fname=sfield.short_name 
           if hasattr(sfield, 'long_name'): fname=sfield.long_name 
           if hasattr(sfield, 'standard_name'): fname=sfield.standard_name
           if hasattr(sfield, 'Units'): units=str(sfield.Units)


           #Work out whether to store the u vector data or to make the vector plot
           make_vector=0
           store_vector=0
           if plot_type == 2 and plotvars.plot_counter == 1:  make_vector=1
           if plot_type == 2 and plotvars.plot_counter == 0:  store_vector=1
           if plot_type == 3 and plotvars.plot_counter == 2:  make_vector=1
           if plot_type == 3 and plotvars.plot_counter == 1:  store_vector=1

              
           
           if make_vector == 1:
              #Make the vector plot
              plotvars.title=plotvars.title+plotvars.vect_title+sfield.file+' '+fname+'('+units+')'+\
                             opstring+subset_string
              #plotvars.title='ajh'+'\\n'+'ajh'
              print 'plotvars.title is ', plotvars.title
              
              ufield=plotvars.vect_ufield
              vfield=sfield
              plotvars.code=plotvars.code+'vfield=sfield\n\n'
              code="cfp.vect(u=ufield, v=vfield, key_length=10, scale=100, stride=5, title='%s')"%plotvars.title
              exec(code)
              plotvars.code=plotvars.code+'\n#Make vector plot\n'
              plotvars.code=plotvars.code+code+'\n\n'

              #reset counters and move on to the next plot
              plotvars.vect_ufield=None
              plotvars.vect_title=''
              plotvars.title=''
              plotvars.pos=plotvars.pos+1
              if plotvars.pos <= plotvars.nplots and plotvars.nplots > 1: 
                 code="cfp.gpos(pos=%s)"%plotvars.pos
                 exec(code)                    
                 plotvars.code=plotvars.code+'\n#Move to next plot position\n'
                 plotvars.code=plotvars.code+code+'\n\n'
              plotvars.plot_counter=plotvars.plot_counter+1


           if store_vector == 1:
              #Store u field in plotvars for use next time around
              plotvars.vect_ufield=sfield
              if plot_type == 3: plotvars.title=plotvars.title+'\\n'
              plotvars.vect_title=sfield.file+' '+fname+'('+units+')'+opstring+subset_string+'\\n'
              plotvars.plot_counter=plotvars.plot_counter+1
              plotvars.code=plotvars.code+'ufield=sfield\n\n'



        #Contour plot
        if ndim == 2 and (plot_type == 1 or plot_type == 3):
           proceed=1
           if plot_type == 3 and plotvars.plot_counter > 1: proceed=0
           if proceed == 1:
              if plotvars.nplots == 1 and plot_type == 3: 
                 code="cfp.gopen()"
                 exec("\n"+code)
                 plotvars.code=plotvars.code+code+'\n'

                 
              if plotOptions['mapset']['proj']<>'cyl': 
                 code="cfp.mapset(proj='%s')"%(plotOptions['mapset']['proj'])
                 exec(code)
                 plotvars.code=plotvars.code+'\n#Set mapping\n'
                 plotvars.code=plotvars.code+code+'\n\n'


              plotvars.title=sfield.file+opstring+subset_string
              
              
              #Assemble contour command from plotOptions
              code="cfp.con(sfield"
              if plotOptions['con']['blockfill']==1:code=code+",blockfill=1"
              if plotOptions['con']['lines']<>1:code=code+",lines=0"
              if plotOptions['con']['fill']<>1:code=code+",fill=0"
              if plotOptions['con']['negative_linestyle']is not None:
                 code=code+",negative_linestyle=%s"%plotOptions['con']['negative_linestyle']
              code=code+",title='%s'"%plotvars.title
              if plotOptions['con']['colorbar_orientation']=='vertical': \
                 code=code+",colorbar_orientation='vertical'"
              if plotOptions['con']['colorbar'] is None: code=code+",colorbar=None"
              code=code+')'

              #old command
              #code="cfp.con(sfield,**plotOptions['con'])"
              
              exec(code)
              plotvars.code=plotvars.code+'#Make contour plot\n'
              plotvars.code=plotvars.code+code+'\n\n'

              if plot_type ==1: plotvars.title=''
              plotvars.plot_counter=plotvars.plot_counter+1
              if plot_type == 1:  
                 plotvars.pos=plotvars.pos+1
                 if plotvars.pos <= plotvars.nplots and plotvars.nplots > 1: 
                    code="cfp.gpos(pos=%s)"%plotvars.pos
                    exec(code)
                    plotvars.code=plotvars.code+'\n#Move to next plot position\n'
                    plotvars.code=plotvars.code+code+'\n\n'



        #Reset counters if a single plot
        if plotvars.nplots == 1:
           plot_reset=0
           if plot_type == 0 or plot_type == 1:  plot_reset=1
           if plot_type == 2 and plotvars.plot_counter == 2: plot_reset=1
           if plot_type == 3 and plotvars.plot_counter == 3: 
              code="cfp.gclose()"
              exec(code)
              plotvars.code=plotvars.code+code+'\n'
              plot_reset=1

           if plot_reset == 1:
              plotvars.nplots=1
              plotvars.pos=0
              plotvars.plot_counter=0
              plotvars.plot_finish=0
              plotvars.title=''


        #Reset counter if the last plot of a contour and vector plot
        if plotvars.nplots > 1 and plot_type == 3 and plotvars.plot_counter == 3:
           plotvars.plot_counter=0

        #Close and view if multiple plot and it is also the last plot
        if plotvars.nplots > 1 and plotvars.pos > plotvars.nplots:
           plotvars.nplots=1
           plotvars.pos=0
           plotvars.plot_counter=0
           plotvars.plot_finish=0
           code="cfp.gclose()"
           exec(code)
           plotvars.code=plotvars.code+code+'\n'





        



          


    def set_data(self,data):
        ''' Set with an open cf dataset object '''
        self.cf_dataset=data
        self.fieldSelector.set_data(data)
        #print 'In data selection'


    def selection(self,data):
        ''' Provided to fieldSelector as a callback, so that when
        fields are selected, the metadata and grid selectors are
        updated. '''
        fields=[self.cf_dataset[i] for i in data]
        plotvars.field_selected='%s'%data
        self.fieldMetadata.set_data(fields)
        self.gridMetadata.set_data(fields)
        self.gridSelector.set_data(fields[0]) 
        self.fields=fields
        
class script:
    ''' Provides a scriptable copy of what the gui is doing '''
    #def __init__(self,debug=True):
    def __init__(self):
        ''' Construct the file header. If debug, write actions 
        as we go along. '''
        self.content=''

    def start(self):
       self.content=\
'''
import cf
import cfplot as cfp
#
# script generated by cfview version %s
#
                    '''%__version__



    def add(self,command,hash=False):
        ''' Add a command to the script, preceded by a hash if hash true '''
        if hash: self.content+='\n#\n'
        # we have to parse the command for things that need escaping
        command=command.replace('\n','\\n')
        self.content+='%s\n'%command
        #if self.debug:self.debug.write('%s\n'%command)

    def clear(self):
       self.content=''



#Show code for making plot in a text window
class code_show:
    def close_application(self, widget):
        widget.destroy()

    def __init__(self, widget):
        window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        window.set_resizable(True)  
        window.connect("destroy", self.close_application)
        window.set_title("cfview - code to make plot")
        window.set_border_width(0)
        window.set_size_request(700, 900)

        box1 = gtk.VBox(False, 0)
        window.add(box1)
        box1.show()

        box2 = gtk.VBox(False, 10)
        box2.set_border_width(10)        
        box1.pack_start(box2, True, True, 0)
        box2.show()

        sw = gtk.ScrolledWindow()
        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        textview = gtk.TextView()
        textbuffer = textview.get_buffer()
        sw.add(textview)
        sw.show()
        textview.show()

        box2.pack_start(sw)
        
        #Set the text view to be plot code.
        textbuffer.set_text(plotvars.code)

        hbox = gtk.HButtonBox()
        hbox.set_size_request(200,100)
        box2.pack_start(hbox, False, False, 0)
        box2.set_size_request(200,100)
        hbox.show()

        vbox = gtk.VBox()
        vbox.show()
        hbox.pack_start(vbox, False, False, 0)
        

        button = gtk.Button("close")        
        button.set_size_request(200,100)
        button.connect("clicked", self.close_application)
        box2.pack_start(button, True, True, 0)
        button.set_flags(gtk.CAN_DEFAULT)
        button.grab_default()
        button.show()
        window.show()



            
def main(filename):
    ''' main loop for cfview '''
    c=cfview(filename)
    gtk.main()
    return 0
        
if __name__=="__main__":
    args=sys.argv
    if len(args)>2:
        print 'Usage: cfview <filename>   (filename is optional)'
    elif len(args)==2:
        main(args[1])
    else: main(None)


